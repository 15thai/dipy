
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DIPY &#8212; dipy 0.16.0 documentation</title>
    <link rel="stylesheet" href="../_static/dipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="sims" href="dipy.sims.html" />
  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head><body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../index.html">
  <img src="../_static/dipy-banner.png" alt="DIPY logo"  border="0" />
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.sims.html" title="sims"
             accesskey="P">previous</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">API Reference</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Site Navigation </h4>
  <ul>
    <li><a href="../documentation.html">Documentation</a></li>
    <li><a href="../devel/index.html">Development</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.org/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.org/">NIPY Projects</a></li>
    <li><a class="reference external"
	href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing List</a></li>
    <li><a class="reference external"
	href="http://nipy.org/nipy/license.html">License</a></li>
  </ul>


  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">stats</span></code></a><ul>
<li><a class="reference internal" href="#module-dipy.stats.analysis">Module: <code class="docutils literal notranslate"><span class="pre">stats.analysis</span></code></a><ul>
<li><a class="reference internal" href="#averagepointwiseeuclideanmetric"><code class="docutils literal notranslate"><span class="pre">AveragePointwiseEuclideanMetric</span></code></a></li>
<li><a class="reference internal" href="#quickbundles"><code class="docutils literal notranslate"><span class="pre">QuickBundles</span></code></a></li>
<li><a class="reference internal" href="#streamlines"><code class="docutils literal notranslate"><span class="pre">Streamlines</span></code></a></li>
<li><a class="reference internal" href="#ckdtree"><code class="docutils literal notranslate"><span class="pre">cKDTree</span></code></a></li>
<li><a class="reference internal" href="#bundle-analysis">bundle_analysis</a></li>
<li><a class="reference internal" href="#dti-measures">dti_measures</a></li>
<li><a class="reference internal" href="#load-nifti">load_nifti</a></li>
<li><a class="reference internal" href="#load-peaks">load_peaks</a></li>
<li><a class="reference internal" href="#load-trk">load_trk</a></li>
<li><a class="reference internal" href="#map-coordinates">map_coordinates</a></li>
<li><a class="reference internal" href="#optional-package">optional_package</a></li>
<li><a class="reference internal" href="#peak-values">peak_values</a></li>
<li><a class="reference internal" href="#set-number-of-points">set_number_of_points</a></li>
<li><a class="reference internal" href="#transform-streamlines">transform_streamlines</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dipy.sims.html"
                        title="previous chapter"><code class="docutils literal notranslate"><span class="pre">sims</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/dipy.stats.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<script>
  ((window.gitter = {}).chat = {}).options = {
      room: 'nipy/dipy'    
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dipy.stats">
<span id="stats"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">stats</span></code><a class="headerlink" href="#module-dipy.stats" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<div class="section" id="module-dipy.stats.analysis">
<span id="module-stats-analysis"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">stats.analysis</span></code><a class="headerlink" href="#module-dipy.stats.analysis" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.AveragePointwiseEuclideanMetric" title="dipy.stats.analysis.AveragePointwiseEuclideanMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AveragePointwiseEuclideanMetric</span></code></a></td>
<td>Computes the average of pointwise Euclidean distances between two sequential data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.QuickBundles" title="dipy.stats.analysis.QuickBundles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuickBundles</span></code></a>(threshold[,&nbsp;metric,&nbsp;…])</td>
<td>Clusters streamlines using QuickBundles <a class="reference internal" href="#r2bead99ec474-garyfallidis12" id="id1">[Garyfallidis12]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.Streamlines" title="dipy.stats.analysis.Streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Streamlines</span></code></a></td>
<td>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.array_sequence.ArraySequence</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.cKDTree" title="dipy.stats.analysis.cKDTree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cKDTree</span></code></a>(data[,&nbsp;leafsize,&nbsp;compact_nodes,&nbsp;…])</td>
<td>kd-tree for quick nearest-neighbor lookup</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.bundle_analysis" title="dipy.stats.analysis.bundle_analysis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_analysis</span></code></a>(model_bundle_folder,&nbsp;…[,&nbsp;…])</td>
<td>Applies statistical analysis on bundles and saves the results in a directory specified by <code class="docutils literal notranslate"><span class="pre">out_dir</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.dti_measures" title="dipy.stats.analysis.dti_measures"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dti_measures</span></code></a>(bundle,&nbsp;metric,&nbsp;dt,&nbsp;pname,&nbsp;…)</td>
<td>Calculates dti measure (eg: FA, MD) per point on streamlines and save it in hd5 file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.load_nifti" title="dipy.stats.analysis.load_nifti"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_nifti</span></code></a>(fname[,&nbsp;return_img,&nbsp;…])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.load_peaks" title="dipy.stats.analysis.load_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_peaks</span></code></a>(fname[,&nbsp;verbose])</td>
<td>Load a PeaksAndMetrics HDF5 file (PAM5)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.load_trk" title="dipy.stats.analysis.load_trk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_trk</span></code></a>(filename[,&nbsp;lazy_load])</td>
<td>Loads tractogram files (<a href="#id2"><span class="problematic" id="id3">*</span></a>.tck)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.map_coordinates" title="dipy.stats.analysis.map_coordinates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_coordinates</span></code></a>(input,&nbsp;coordinates[,&nbsp;…])</td>
<td>Map the input array to new coordinates by interpolation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.optional_package" title="dipy.stats.analysis.optional_package"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optional_package</span></code></a>(name[,&nbsp;trip_msg])</td>
<td>Return package-like thing and module setup for package <cite>name</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.peak_values" title="dipy.stats.analysis.peak_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">peak_values</span></code></a>(bundle,&nbsp;peaks,&nbsp;dt,&nbsp;pname,&nbsp;bname,&nbsp;…)</td>
<td>Peak_values function finds the peak direction and peak value of a point on a streamline used while tracking (generating the tractogram) and save it in hd5 file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.set_number_of_points" title="dipy.stats.analysis.set_number_of_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_number_of_points</span></code></a></td>
<td>Change the number of points of streamlines</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.transform_streamlines" title="dipy.stats.analysis.transform_streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_streamlines</span></code></a>(streamlines,&nbsp;mat[,&nbsp;…])</td>
<td>Apply affine transformation to streamlines</td>
</tr>
</tbody>
</table>
<div class="section" id="averagepointwiseeuclideanmetric">
<h3><a class="reference internal" href="#dipy.stats.analysis.AveragePointwiseEuclideanMetric" title="dipy.stats.analysis.AveragePointwiseEuclideanMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragePointwiseEuclideanMetric</span></code></a><a class="headerlink" href="#averagepointwiseeuclideanmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.stats.analysis.AveragePointwiseEuclideanMetric">
<em class="property">class </em><code class="descclassname">dipy.stats.analysis.</code><code class="descname">AveragePointwiseEuclideanMetric</code><a class="headerlink" href="#dipy.stats.analysis.AveragePointwiseEuclideanMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.metricspeed.SumPointwiseEuclideanMetric</span></code></p>
<p>Computes the average of pointwise Euclidean distances between two
sequential data.</p>
<p>A sequence of N-dimensional points is represented as a 2D array with
shape (nb_points, nb_dimensions). A <cite>feature</cite> object can be specified
in order to calculate the distance between the features, rather than
directly between the sequential data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>feature</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>Feature</cite> object, optional</span></dt>
<dd><p class="first last">It is used to extract features before computing the distance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The distance between two 2D sequential data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s1</span>       <span class="n">s2</span>

<span class="mi">0</span><span class="o">*</span>   <span class="n">a</span>    <span class="o">*</span><span class="mi">0</span>
  \       <span class="o">|</span>
   \      <span class="o">|</span>
   <span class="mi">1</span><span class="o">*</span>     <span class="o">|</span>
    <span class="o">|</span>  <span class="n">b</span>  <span class="o">*</span><span class="mi">1</span>
    <span class="o">|</span>      \
    <span class="mi">2</span><span class="o">*</span>      \
        <span class="n">c</span>    <span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p>is equal to <span class="math notranslate nohighlight">\((a+b+c)/3\)</span> where <span class="math notranslate nohighlight">\(a\)</span> is the Euclidean distance between s1[0] and
s2[0], <span class="math notranslate nohighlight">\(b\)</span> between s1[1] and s2[1] and <span class="math notranslate nohighlight">\(c\)</span> between s1[2] and s2[2].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature</span></code></dt>
<dd><p class="first last"><cite>Feature</cite> object used to extract features from sequential data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_order_invariant</span></code></dt>
<dd><p class="first last">Is this metric invariant to the sequence’s ordering</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_compatible</span></code></td>
<td>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dist</span></code></td>
<td>Computes a distance between two data points based on their features.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.stats.analysis.AveragePointwiseEuclideanMetric.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.AveragePointwiseEuclideanMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="quickbundles">
<h3><a class="reference internal" href="#dipy.stats.analysis.QuickBundles" title="dipy.stats.analysis.QuickBundles"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuickBundles</span></code></a><a class="headerlink" href="#quickbundles" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.stats.analysis.QuickBundles">
<em class="property">class </em><code class="descclassname">dipy.stats.analysis.</code><code class="descname">QuickBundles</code><span class="sig-paren">(</span><em>threshold</em>, <em>metric='MDF_12points'</em>, <em>max_nb_clusters=2147483647</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.QuickBundles" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="dipy.segment.html#dipy.segment.clustering.Clustering" title="dipy.segment.clustering.Clustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.segment.clustering.Clustering</span></code></a></p>
<p>Clusters streamlines using QuickBundles <a class="reference internal" href="#r2bead99ec474-garyfallidis12" id="id4">[Garyfallidis12]</a>.</p>
<p>Given a list of streamlines, the QuickBundles algorithm sequentially
assigns each streamline to its closest bundle in <span class="math notranslate nohighlight">\(\mathcal{O}(Nk)\)</span> where
<span class="math notranslate nohighlight">\(N\)</span> is the number of streamlines and <span class="math notranslate nohighlight">\(k\)</span> is the final number of bundles.
If for a given streamline its closest bundle is farther than <cite>threshold</cite>,
a new bundle is created and the streamline is assigned to it except if the
number of bundles has already exceeded <cite>max_nb_clusters</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum distance from a bundle for a streamline to be still
considered as part of it.</p>
</dd>
<dt><strong>metric</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or <cite>Metric</cite> object (optional)</span></dt>
<dd><p class="first last">The distance metric to use when comparing two streamlines. By default,
the Minimum average Direct-Flip (MDF) distance <a class="reference internal" href="#r2bead99ec474-garyfallidis12" id="id5">[Garyfallidis12]</a> is
used and streamlines are automatically resampled so they have
12 points.</p>
</dd>
<dt><strong>max_nb_clusters</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Limits the creation of bundles.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2bead99ec474-garyfallidis12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Garyfallidis12]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id5">3</a>, <a class="fn-backref" href="#id6">4</a>)</em> Garyfallidis E. et al., QuickBundles a method for
tractography simplification, Frontiers in Neuroscience,
vol 6, no 175, 2012.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.segment.clustering</span> <span class="k">import</span> <span class="n">QuickBundles</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_fnames</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nibabel</span> <span class="k">import</span> <span class="n">trackvis</span> <span class="k">as</span> <span class="n">tv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streams</span><span class="p">,</span> <span class="n">hdr</span> <span class="o">=</span> <span class="n">tv</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">get_fnames</span><span class="p">(</span><span class="s1">&#39;fornix&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">streams</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Segment fornix with a treshold of 10mm and streamlines resampled</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># to 12 points.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qb</span> <span class="o">=</span> <span class="n">QuickBundles</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">10.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">streamlines</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">clusters</span><span class="p">))</span>
<span class="go">[61, 191, 47, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Resampling streamlines differently is done explicitly as follows.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note this has an impact on the speed and the accuracy (tradeoff).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.segment.metric</span> <span class="k">import</span> <span class="n">ResampleFeature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.segment.metric</span> <span class="k">import</span> <span class="n">AveragePointwiseEuclideanMetric</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feature</span> <span class="o">=</span> <span class="n">ResampleFeature</span><span class="p">(</span><span class="n">nb_points</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metric</span> <span class="o">=</span> <span class="n">AveragePointwiseEuclideanMetric</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qb</span> <span class="o">=</span> <span class="n">QuickBundles</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">streamlines</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">clusters</span><span class="p">))</span>
<span class="go">[58, 142, 72, 28]</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.QuickBundles.cluster" title="dipy.stats.analysis.QuickBundles.cluster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cluster</span></code></a>(streamlines[,&nbsp;ordering])</td>
<td>Clusters <cite>streamlines</cite> into bundles.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.stats.analysis.QuickBundles.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>threshold</em>, <em>metric='MDF_12points'</em>, <em>max_nb_clusters=2147483647</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.QuickBundles.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.stats.analysis.QuickBundles.cluster">
<code class="descname">cluster</code><span class="sig-paren">(</span><em>streamlines</em>, <em>ordering=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.QuickBundles.cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters <cite>streamlines</cite> into bundles.</p>
<p>Performs quickbundles algorithm using predefined metric and threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>streamlines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of 2D arrays</span></dt>
<dd><p class="first last">Each 2D array represents a sequence of 3D points (points, 3).</p>
</dd>
<dt><strong>ordering</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of indices</span></dt>
<dd><p class="first last">Specifies the order in which data points will be clustered.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>`ClusterMapCentroid` object</strong></dt>
<dd><p class="first last">Result of the clustering.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="streamlines">
<h3><a class="reference internal" href="#dipy.stats.analysis.Streamlines" title="dipy.stats.analysis.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Streamlines</span></code></a><a class="headerlink" href="#streamlines" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.stats.analysis.Streamlines">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">Streamlines</code><a class="headerlink" href="#dipy.stats.analysis.Streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.array_sequence.ArraySequence</span></code></p>
</dd></dl>

</div>
<div class="section" id="ckdtree">
<h3><a class="reference internal" href="#dipy.stats.analysis.cKDTree" title="dipy.stats.analysis.cKDTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">cKDTree</span></code></a><a class="headerlink" href="#ckdtree" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.stats.analysis.cKDTree">
<em class="property">class </em><code class="descclassname">dipy.stats.analysis.</code><code class="descname">cKDTree</code><span class="sig-paren">(</span><em>data</em>, <em>leafsize=16</em>, <em>compact_nodes=True</em>, <em>copy_data=False</em>, <em>balanced_tree=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.cKDTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>kd-tree for quick nearest-neighbor lookup</p>
<p>This class provides an index into a set of k-dimensional points
which can be used to rapidly look up the nearest neighbors of any
point.</p>
<p>The algorithm used is described in Maneewongvatana and Mount 1999. 
The general idea is that the kd-tree is a binary trie, each of whose
nodes represents an axis-aligned hyperrectangle. Each node specifies
an axis and splits the set of points based on whether their coordinate
along that axis is greater than or less than a particular value.</p>
<p>During construction, the axis and splitting point are chosen by the 
“sliding midpoint” rule, which ensures that the cells do not all
become long and thin.</p>
<p>The tree can be queried for the r closest neighbors of any given point 
(optionally returning only those within some maximum distance of the 
point). It can also be queried, with a substantial gain in efficiency, 
for the r approximate closest neighbors.</p>
<p>For large dimensions (20 is already large) do not expect this to run 
significantly faster than brute force. High-dimensional nearest-neighbor
queries are a substantial open problem in computer science.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape (n,m)</span></dt>
<dd><p class="first last">The n data points of dimension m to be indexed. This array is 
not copied unless this is necessary to produce a contiguous 
array of doubles, and so modifying this data will result in 
bogus results. The data are also copied if the kd-tree is built
with copy_data=True.</p>
</dd>
<dt><strong>leafsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">positive int, optional</span></dt>
<dd><p class="first last">The number of points at which the algorithm switches over to
brute-force. Default: 16.</p>
</dd>
<dt><strong>compact_nodes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, the kd-tree is built to shrink the hyperrectangles to
the actual data range. This usually gives a more compact tree that 
is robust against degenerated input data and gives faster queries 
at the expense of longer build time. Default: True.</p>
</dd>
<dt><strong>copy_data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True the data is always copied to protect the kd-tree against 
data corruption. Default: False.</p>
</dd>
<dt><strong>balanced_tree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, the median is used to split the hyperrectangles instead of 
the midpoint. This usually gives a more compact tree and 
faster queries at the expense of longer build time. Default: True.</p>
</dd>
<dt><strong>boxsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like or scalar, optional</span></dt>
<dd><p class="first last">Apply a m-d toroidal topology to the KDTree.. The topology is generated 
by <span class="math notranslate nohighlight">\(x_i + n_i L_i\)</span> where <span class="math notranslate nohighlight">\(n_i\)</span> are integers and <span class="math notranslate nohighlight">\(L_i\)</span>
is the boxsize along i-th dimension. The input data shall be wrapped 
into <span class="math notranslate nohighlight">\([0, L_i)\)</span>. A ValueError is raised if any of the data is
outside of this bound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">KDTree</span></code></dt>
<dd>Implementation of <cite>cKDTree</cite> in pure Python</dd>
</dl>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n,m)</span></dt>
<dd><p class="first last">The n data points of dimension m to be indexed. This array is
not copied unless this is necessary to produce a contiguous
array of doubles. The data are also copied if the kd-tree is built
with <cite>copy_data=True</cite>.</p>
</dd>
<dt><strong>leafsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">positive int</span></dt>
<dd><p class="first last">The number of points at which the algorithm switches over to
brute-force.</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The dimension of a single data-point.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of data points.</p>
</dd>
<dt><strong>maxes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (m,)</span></dt>
<dd><p class="first last">The maximum value in each dimension of the n data points.</p>
</dd>
<dt><strong>mins</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (m,)</span></dt>
<dd><p class="first last">The minimum value in each dimension of the n data points.</p>
</dd>
<dt><strong>tree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object, class cKDTreeNode</span></dt>
<dd><p class="first last">This class exposes a Python view of the root node in the cKDTree object.</p>
</dd>
<dt><strong>size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of nodes in the tree.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.cKDTree.count_neighbors" title="dipy.stats.analysis.cKDTree.count_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_neighbors</span></code></a>(self,&nbsp;other,&nbsp;r[,&nbsp;p,&nbsp;…])</td>
<td>Count how many nearby pairs can be formed.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.cKDTree.query" title="dipy.stats.analysis.cKDTree.query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">query</span></code></a>(self,&nbsp;x[,&nbsp;k,&nbsp;eps,&nbsp;p,&nbsp;…])</td>
<td>Query the kd-tree for nearest neighbors</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.cKDTree.query_ball_point" title="dipy.stats.analysis.cKDTree.query_ball_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">query_ball_point</span></code></a>(self,&nbsp;x,&nbsp;r[,&nbsp;p,&nbsp;eps])</td>
<td>Find all points within distance r of point(s) x.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.cKDTree.query_ball_tree" title="dipy.stats.analysis.cKDTree.query_ball_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">query_ball_tree</span></code></a>(self,&nbsp;other,&nbsp;r[,&nbsp;p,&nbsp;eps])</td>
<td>Find all pairs of points whose distance is at most r</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.stats.analysis.cKDTree.query_pairs" title="dipy.stats.analysis.cKDTree.query_pairs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">query_pairs</span></code></a>(self,&nbsp;r[,&nbsp;p,&nbsp;eps])</td>
<td>Find all pairs of points whose distance is at most r.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.stats.analysis.cKDTree.sparse_distance_matrix" title="dipy.stats.analysis.cKDTree.sparse_distance_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_distance_matrix</span></code></a>(self,&nbsp;other,&nbsp;max_distance)</td>
<td>Compute a sparse distance matrix</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.stats.analysis.cKDTree.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.cKDTree.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.boxsize">
<code class="descname">boxsize</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.boxsize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.stats.analysis.cKDTree.count_neighbors">
<code class="descname">count_neighbors</code><span class="sig-paren">(</span><em>self</em>, <em>other</em>, <em>r</em>, <em>p=2.</em>, <em>weights=None</em>, <em>cumulative=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.cKDTree.count_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Count how many nearby pairs can be formed. (pair-counting)</p>
<p>Count the number of pairs (x1,x2) can be formed, with x1 drawn
from self and x2 drawn from <code class="docutils literal notranslate"><span class="pre">other</span></code>, and where
<code class="docutils literal notranslate"><span class="pre">distance(x1,</span> <span class="pre">x2,</span> <span class="pre">p)</span> <span class="pre">&lt;=</span> <span class="pre">r</span></code>.</p>
<p>Data points on self and other are optionally weighted by the <code class="docutils literal notranslate"><span class="pre">weights</span></code>
argument. (See below)</p>
<p>The algorithm we implement here is based on <a class="reference internal" href="#r6517d87a3955-1" id="id7">[1]</a>. See notes for further discussion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">cKDTree instance</span></dt>
<dd><p class="first last">The other tree to draw points from, can be the same tree as self.</p>
</dd>
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or one-dimensional array of floats</span></dt>
<dd><p class="first last">The radius to produce a count for. Multiple radii are searched with
a single tree traversal. 
If the count is non-cumulative(<code class="docutils literal notranslate"><span class="pre">cumulative=False</span></code>), <code class="docutils literal notranslate"><span class="pre">r</span></code> defines 
the edges of the bins, and must be non-decreasing.</p>
</dd>
<dt><strong>p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">1&lt;=p&lt;=infinity. 
Which Minkowski p-norm to use.
Default 2.0.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, array_like, or None, optional</span></dt>
<dd><p class="first last">If None, the pair-counting is unweighted.
If given as a tuple, weights[0] is the weights of points in <code class="docutils literal notranslate"><span class="pre">self</span></code>, and
weights[1] is the weights of points in <code class="docutils literal notranslate"><span class="pre">other</span></code>; either can be None to 
indicate the points are unweighted.
If given as an array_like, weights is the weights of points in <code class="docutils literal notranslate"><span class="pre">self</span></code>
and <code class="docutils literal notranslate"><span class="pre">other</span></code>. For this to make sense, <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> must be the
same tree. If <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are two different trees, a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>
is raised.
Default: None</p>
</dd>
<dt><strong>cumulative</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether the returned counts are cumulative. When cumulative is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>
the algorithm is optimized to work with a large number of bins (&gt;10) specified
by <code class="docutils literal notranslate"><span class="pre">r</span></code>. When <code class="docutils literal notranslate"><span class="pre">cumulative</span></code> is set to True, the algorithm is optimized to work
with a small number of <code class="docutils literal notranslate"><span class="pre">r</span></code>. Default: True</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar or 1-D array</span></dt>
<dd><p class="first last">The number of pairs. For unweighted counts, the result is integer.
For weighted counts, the result is float.
If cumulative is False, <code class="docutils literal notranslate"><span class="pre">result[i]</span></code> contains the counts with
<code class="docutils literal notranslate"><span class="pre">(-inf</span> <span class="pre">if</span> <span class="pre">i</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">else</span> <span class="pre">r[i-1])</span> <span class="pre">&lt;</span> <span class="pre">R</span> <span class="pre">&lt;=</span> <span class="pre">r[i]</span></code></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Pair-counting is the basic operation used to calculate the two point
correlation functions from a data set composed of position of objects.</p>
<p>Two point correlation function measures the clustering of objects and
is widely used in cosmology to quantify the large scale structure
in our Universe, but it may be useful for data analysis in other fields
where self-similar assembly of objects also occur.</p>
<p>The Landy-Szalay estimator for the two point correlation function of
<code class="docutils literal notranslate"><span class="pre">D</span></code> measures the clustering signal in <code class="docutils literal notranslate"><span class="pre">D</span></code>. <a class="reference internal" href="#r6517d87a3955-2" id="id8">[2]</a></p>
<p>For example, given the position of two sets of objects,</p>
<ul class="simple">
<li>objects <code class="docutils literal notranslate"><span class="pre">D</span></code> (data) contains the clustering signal, and</li>
<li>objects <code class="docutils literal notranslate"><span class="pre">R</span></code> (random) that contains no signal,</li>
</ul>
<div class="math notranslate nohighlight">
\[\xi(r) = \frac{&lt;D, D&gt; - 2 f &lt;D, R&gt; + f^2&lt;R, R&gt;}{f^2&lt;R, R&gt;},\]</div>
<p>where the brackets represents counting pairs between two data sets
in a finite bin around <code class="docutils literal notranslate"><span class="pre">r</span></code> (distance), corresponding to setting
<cite>cumulative=False</cite>, and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">float(len(D))</span> <span class="pre">/</span> <span class="pre">float(len(R))</span></code> is the
ratio between number of objects from data and random.</p>
<p>The algorithm implemented here is loosely based on the dual-tree
algorithm described in <a class="reference internal" href="#r6517d87a3955-1" id="id9">[1]</a>. We switch between two different
pair-cumulation scheme depending on the setting of <code class="docutils literal notranslate"><span class="pre">cumulative</span></code>.
The computing time of the method we use when for
<code class="docutils literal notranslate"><span class="pre">cumulative</span> <span class="pre">==</span> <span class="pre">False</span></code> does not scale with the total number of bins.
The algorithm for <code class="docutils literal notranslate"><span class="pre">cumulative</span> <span class="pre">==</span> <span class="pre">True</span></code> scales linearly with the
number of bins, though it is slightly faster when only
1 or 2 bins are used. <a class="reference internal" href="#r6517d87a3955-5" id="id10">[5]</a>.</p>
<p>As an extension to the naive pair-counting,
weighted pair-counting counts the product of weights instead
of number of pairs.
Weighted pair-counting is used to estimate marked correlation functions
(<a class="reference internal" href="#r6517d87a3955-3" id="id11">[3]</a>, section 2.2),
or to properly calculate the average of data per distance bin
(e.g. <a class="reference internal" href="#r6517d87a3955-4" id="id12">[4]</a>, section 2.1 on redshift).</p>
<table class="docutils citation" frame="void" id="r6517d87a3955-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> Gray and Moore,
“N-body problems in statistical learning”,
Mining the sky, 2000,
<a class="reference external" href="https://arxiv.org/abs/astro-ph/0012333">https://arxiv.org/abs/astro-ph/0012333</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6517d87a3955-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[2]</a></td><td>Landy and Szalay,
“Bias and variance of angular correlation functions”,
The Astrophysical Journal, 1993,
<a class="reference external" href="http://adsabs.harvard.edu/abs/1993ApJ...412...64L">http://adsabs.harvard.edu/abs/1993ApJ…412…64L</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6517d87a3955-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[3]</a></td><td>Sheth, Connolly and Skibba,
“Marked correlations in galaxy formation models”,
Arxiv e-print, 2005,
<a class="reference external" href="https://arxiv.org/abs/astro-ph/0511773">https://arxiv.org/abs/astro-ph/0511773</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6517d87a3955-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[4]</a></td><td>Hawkins, et al.,
“The 2dF Galaxy Redshift Survey: correlation functions,
peculiar velocities and the matter density of the Universe”,
Monthly Notices of the Royal Astronomical Society, 2002,
<a class="reference external" href="http://adsabs.harvard.edu/abs/2003MNRAS.346...78H">http://adsabs.harvard.edu/abs/2003MNRAS.346…78H</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6517d87a3955-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[5]</a></td><td><a class="reference external" href="https://github.com/scipy/scipy/pull/5647#issuecomment-168474926">https://github.com/scipy/scipy/pull/5647#issuecomment-168474926</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.data">
<code class="descname">data</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.indices">
<code class="descname">indices</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.leafsize">
<code class="descname">leafsize</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.leafsize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.m">
<code class="descname">m</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.m" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.maxes">
<code class="descname">maxes</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.maxes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.mins">
<code class="descname">mins</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.mins" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.n">
<code class="descname">n</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.n" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.stats.analysis.cKDTree.query">
<code class="descname">query</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>k=1</em>, <em>eps=0</em>, <em>p=2</em>, <em>distance_upper_bound=np.inf</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.cKDTree.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Query the kd-tree for nearest neighbors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, last dimension self.m</span></dt>
<dd><p class="first last">An array of points to query.</p>
</dd>
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of integer or integer</span></dt>
<dd><p class="first last">The list of k-th nearest neighbors to return. If k is an 
integer it is treated as a list of [1, … k] (range(1, k+1)).
Note that the counting starts from 1.</p>
</dd>
<dt><strong>eps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-negative float</span></dt>
<dd><p class="first last">Return approximate nearest neighbors; the k-th returned value 
is guaranteed to be no further than (1+eps) times the 
distance to the real k-th nearest neighbor.</p>
</dd>
<dt><strong>p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, 1&lt;=p&lt;=infinity</span></dt>
<dd><p class="first last">Which Minkowski p-norm to use. 
1 is the sum-of-absolute-values “Manhattan” distance
2 is the usual Euclidean distance
infinity is the maximum-coordinate-difference distance</p>
</dd>
<dt><strong>distance_upper_bound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">nonnegative float</span></dt>
<dd><p class="first last">Return only neighbors within this distance.  This is used to prune
tree searches, so if you are doing a series of nearest-neighbor
queries, it may help to supply the distance to the nearest neighbor
of the most recent point.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of jobs to schedule for parallel processing. If -1 is given
all processors are used. Default: 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of floats</span></dt>
<dd><p class="first last">The distances to the nearest neighbors. 
If <code class="docutils literal notranslate"><span class="pre">x</span></code> has shape <code class="docutils literal notranslate"><span class="pre">tuple+(self.m,)</span></code>, then <code class="docutils literal notranslate"><span class="pre">d</span></code> has shape <code class="docutils literal notranslate"><span class="pre">tuple+(k,)</span></code>.
When k == 1, the last dimension of the output is squeezed.
Missing neighbors are indicated with infinite distances.</p>
</dd>
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of ints</span></dt>
<dd><p class="first last">The locations of the neighbors in <code class="docutils literal notranslate"><span class="pre">self.data</span></code>.
If <code class="docutils literal notranslate"><span class="pre">x</span></code> has shape <code class="docutils literal notranslate"><span class="pre">tuple+(self.m,)</span></code>, then <code class="docutils literal notranslate"><span class="pre">i</span></code> has shape <code class="docutils literal notranslate"><span class="pre">tuple+(k,)</span></code>.
When k == 1, the last dimension of the output is squeezed.
Missing neighbors are indicated with <code class="docutils literal notranslate"><span class="pre">self.n</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If the KD-Tree is periodic, the position <code class="docutils literal notranslate"><span class="pre">x</span></code> is wrapped into the
box.</p>
<p>When the input k is a list, a query for arange(max(k)) is performed, but
only columns that store the requested values of k are preserved. This is 
implemented in a manner that reduces memory usage.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">cKDTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>
</pre></div>
</div>
<p>To query the nearest neighbours and return squeezed result, use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">]],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
<span class="go">[2.         0.14142136] [ 0 13]</span>
</pre></div>
</div>
<p>To query the nearest neighbours and return unsqueezed result, use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">]],</span> <span class="n">k</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
<span class="go">[[2.        ]</span>
<span class="go"> [0.14142136]] [[ 0]</span>
<span class="go"> [13]]</span>
</pre></div>
</div>
<p>To query the second nearest neighbours and return unsqueezed result, use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">]],</span> <span class="n">k</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
<span class="go">[[2.23606798]</span>
<span class="go"> [0.90553851]] [[ 6]</span>
<span class="go"> [12]]</span>
</pre></div>
</div>
<p>To query the first and second nearest neighbours, use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">]],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
<span class="go">[[2.         2.23606798]</span>
<span class="go"> [0.14142136 0.90553851]] [[ 0  6]</span>
<span class="go"> [13 12]]</span>
</pre></div>
</div>
<p>or, be more specific</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">]],</span> <span class="n">k</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
<span class="go">[[2.         2.23606798]</span>
<span class="go"> [0.14142136 0.90553851]] [[ 0  6]</span>
<span class="go"> [13 12]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.stats.analysis.cKDTree.query_ball_point">
<code class="descname">query_ball_point</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>r</em>, <em>p=2.</em>, <em>eps=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.cKDTree.query_ball_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all points within distance r of point(s) x.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape tuple + (self.m,)</span></dt>
<dd><p class="first last">The point or points to search for neighbors of.</p>
</dd>
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">positive float</span></dt>
<dd><p class="first last">The radius of points to return.</p>
</dd>
<dt><strong>p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Which Minkowski p-norm to use.  Should be in the range [1, inf].</p>
</dd>
<dt><strong>eps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">nonnegative float, optional</span></dt>
<dd><p class="first last">Approximate search. Branches of the tree are not explored if their
nearest points are further than <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">/</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">eps)</span></code>, and branches are
added in bulk if their furthest points are nearer than
<code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">eps)</span></code>.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of jobs to schedule for parallel processing. If -1 is given
all processors are used. Default: 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>results</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or array of lists</span></dt>
<dd><p class="first last">If <cite>x</cite> is a single point, returns a list of the indices of the
neighbors of <cite>x</cite>. If <cite>x</cite> is an array of points, returns an object
array of shape tuple containing lists of neighbors.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If you have many points whose neighbors you want to find, you may save
substantial amounts of time by putting them in a cKDTree and using
query_ball_tree.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">spatial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[4, 8, 9, 12]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.stats.analysis.cKDTree.query_ball_tree">
<code class="descname">query_ball_tree</code><span class="sig-paren">(</span><em>self</em>, <em>other</em>, <em>r</em>, <em>p=2.</em>, <em>eps=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.cKDTree.query_ball_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all pairs of points whose distance is at most r</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">cKDTree instance</span></dt>
<dd><p class="first last">The tree containing points to search against.</p>
</dd>
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum distance, has to be positive.</p>
</dd>
<dt><strong>p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Which Minkowski norm to use.  <cite>p</cite> has to meet the condition
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">p</span> <span class="pre">&lt;=</span> <span class="pre">infinity</span></code>.</p>
</dd>
<dt><strong>eps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Approximate search.  Branches of the tree are not explored
if their nearest points are further than <code class="docutils literal notranslate"><span class="pre">r/(1+eps)</span></code>, and
branches are added in bulk if their furthest points are nearer
than <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">*</span> <span class="pre">(1+eps)</span></code>.  <cite>eps</cite> has to be non-negative.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>results</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of lists</span></dt>
<dd><p class="first last">For each element <code class="docutils literal notranslate"><span class="pre">self.data[i]</span></code> of this tree, <code class="docutils literal notranslate"><span class="pre">results[i]</span></code> is a
list of the indices of its neighbors in <code class="docutils literal notranslate"><span class="pre">other.data</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.stats.analysis.cKDTree.query_pairs">
<code class="descname">query_pairs</code><span class="sig-paren">(</span><em>self</em>, <em>r</em>, <em>p=2.</em>, <em>eps=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.cKDTree.query_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all pairs of points whose distance is at most r.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">positive float</span></dt>
<dd><p class="first last">The maximum distance.</p>
</dd>
<dt><strong>p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Which Minkowski norm to use.  <code class="docutils literal notranslate"><span class="pre">p</span></code> has to meet the condition
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">p</span> <span class="pre">&lt;=</span> <span class="pre">infinity</span></code>.</p>
</dd>
<dt><strong>eps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Approximate search.  Branches of the tree are not explored
if their nearest points are further than <code class="docutils literal notranslate"><span class="pre">r/(1+eps)</span></code>, and
branches are added in bulk if their furthest points are nearer
than <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">*</span> <span class="pre">(1+eps)</span></code>.  <cite>eps</cite> has to be non-negative.</p>
</dd>
<dt><strong>output_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first last">Choose the output container, ‘set’ or ‘ndarray’. Default: ‘set’</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>results</strong> <span class="classifier-delimiter">:</span> <span class="classifier">set or ndarray</span></dt>
<dd><p class="first last">Set of pairs <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>, with <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>, for which the corresponding
positions are close. If output_type is ‘ndarray’, an ndarry is 
returned instead of a set.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.size">
<code class="descname">size</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.stats.analysis.cKDTree.sparse_distance_matrix">
<code class="descname">sparse_distance_matrix</code><span class="sig-paren">(</span><em>self</em>, <em>other</em>, <em>max_distance</em>, <em>p=2.</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.cKDTree.sparse_distance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a sparse distance matrix</p>
<p>Computes a distance matrix between two cKDTrees, leaving as zero
any distance greater than max_distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">cKDTree</span></dt>
<dd></dd>
<dt><strong>max_distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">positive float</span></dt>
<dd></dd>
<dt><strong>p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, 1&lt;=p&lt;=infinity</span></dt>
<dd><p class="first last">Which Minkowski p-norm to use.</p>
</dd>
<dt><strong>output_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first last">Which container to use for output data. Options: ‘dok_matrix’,
‘coo_matrix’, ‘dict’, or ‘ndarray’. Default: ‘dok_matrix’.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dok_matrix, coo_matrix, dict or ndarray</span></dt>
<dd><p class="first last">Sparse matrix representing the results in “dictionary of keys” 
format. If a dict is returned the keys are (i,j) tuples of indices.
If output_type is ‘ndarray’ a record array with fields ‘i’, ‘j’,
and ‘k’ is returned,</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.stats.analysis.cKDTree.tree">
<code class="descname">tree</code><a class="headerlink" href="#dipy.stats.analysis.cKDTree.tree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="bundle-analysis">
<h3>bundle_analysis<a class="headerlink" href="#bundle-analysis" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.bundle_analysis">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">bundle_analysis</code><span class="sig-paren">(</span><em>model_bundle_folder</em>, <em>bundle_folder</em>, <em>orig_bundle_folder</em>, <em>metric_folder</em>, <em>group</em>, <em>subject</em>, <em>no_disks=100</em>, <em>out_dir=''</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.bundle_analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies statistical analysis on bundles and saves the results
in a directory specified by <code class="docutils literal notranslate"><span class="pre">out_dir</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model_bundle_folder</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Path to the input model bundle files. This path may contain
wildcards to process multiple inputs at once.</p>
</dd>
<dt><strong>bundle_folder</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Path to the input bundle files in common space. This path may
contain wildcards to process multiple inputs at once.</p>
</dd>
<dt><strong>orig_folder</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Path to the input bundle files in native space. This path may
contain wildcards to process multiple inputs at once.</p>
</dd>
<dt><strong>metric_folder</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Path to the input dti metric or/and peak files. It will be used as
metric for statistical analysis of bundles.</p>
</dd>
<dt><strong>group</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">what group subject belongs to e.g. control or patient</p>
</dd>
<dt><strong>subject</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">subject id e.g. 10001</p>
</dd>
<dt><strong>no_disks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer, optional</span></dt>
<dd><p class="first last">Number of disks used for dividing bundle into disks. (Default 100)</p>
</dd>
<dt><strong>out_dir</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first last">Output directory (default input file directory)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re83c634fc031-chandio19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[Chandio19]</a></td><td>Chandio, B.Q., S. Koudoro, D. Reagan, J. Harezlak,</td></tr>
</tbody>
</table>
<p>E. Garyfallidis, Bundle Analytics: a computational and statistical
analyses framework for tractometric studies, Proceedings of:
International Society of Magnetic Resonance in Medicine (ISMRM),
Montreal, Canada, 2019.</p>
</dd></dl>

</div>
<div class="section" id="dti-measures">
<h3>dti_measures<a class="headerlink" href="#dti-measures" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.dti_measures">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">dti_measures</code><span class="sig-paren">(</span><em>bundle</em>, <em>metric</em>, <em>dt</em>, <em>pname</em>, <em>bname</em>, <em>subject</em>, <em>group</em>, <em>ind</em>, <em>dir</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.dti_measures" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates dti measure (eg: FA, MD) per point on streamlines and
save it in hd5 file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bundle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Name of bundle being analyzed</p>
</dd>
<dt><strong>metric</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix of float values</span></dt>
<dd><p class="first last">dti metric e.g. FA, MD</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">DataFrame to be populated</p>
</dd>
<dt><strong>pname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Name of the dti metric</p>
</dd>
<dt><strong>bname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Name of bundle being analyzed.</p>
</dd>
<dt><strong>subject</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">subject number as a string (e.g. 10001)</p>
</dd>
<dt><strong>group</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">which group subject belongs to (e.g. patient or control)</p>
</dd>
<dt><strong>ind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer list</span></dt>
<dd><p class="first last">ind tells which disk number a point belong.</p>
</dd>
<dt><strong>dir</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">path of output directory</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="load-nifti">
<h3>load_nifti<a class="headerlink" href="#load-nifti" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.load_nifti">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">load_nifti</code><span class="sig-paren">(</span><em>fname</em>, <em>return_img=False</em>, <em>return_voxsize=False</em>, <em>return_coords=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.load_nifti" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="load-peaks">
<h3>load_peaks<a class="headerlink" href="#load-peaks" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.load_peaks">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">load_peaks</code><span class="sig-paren">(</span><em>fname</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.load_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a PeaksAndMetrics HDF5 file (PAM5)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Filename of PAM5 file.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Print summary information about the loaded file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pam</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PeaksAndMetrics object</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="load-trk">
<h3>load_trk<a class="headerlink" href="#load-trk" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.load_trk">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">load_trk</code><span class="sig-paren">(</span><em>filename</em>, <em>lazy_load=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.load_trk" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads tractogram files (<a href="#id14"><span class="problematic" id="id15">*</span></a>.tck)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">input trk filename</p>
</dd>
<dt><strong>lazy_load</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{False, True}, optional</span></dt>
<dd><p class="first last">If True, load streamlines in a lazy manner i.e. they will not be kept
in memory and only be loaded when needed.
Otherwise, load all streamlines in memory.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>streamlines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of 2D arrays</span></dt>
<dd><p class="first last">Each 2D array represents a sequence of 3D points (points, 3).</p>
</dd>
<dt><strong>hdr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">header from a trk file</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="map-coordinates">
<h3>map_coordinates<a class="headerlink" href="#map-coordinates" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.map_coordinates">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">map_coordinates</code><span class="sig-paren">(</span><em>input</em>, <em>coordinates</em>, <em>output=None</em>, <em>order=3</em>, <em>mode='constant'</em>, <em>cval=0.0</em>, <em>prefilter=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.map_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the input array to new coordinates by interpolation.</p>
<p>The array of coordinates is used to find, for each point in the output,
the corresponding coordinates in the input. The value of the input at
those coordinates is determined by spline interpolation of the
requested order.</p>
<p>The shape of the output is derived from that of the coordinate
array by dropping the first axis. The values of the array along
the first axis are the coordinates in the input array at which the
output value is found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>input</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">The input array.</p>
</dd>
<dt><strong>coordinates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">The coordinates at which <cite>input</cite> is evaluated.</p>
</dd>
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or dtype, optional</span></dt>
<dd><p class="first last">The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</span></dt>
<dd><p class="first">The <cite>mode</cite> parameter determines how the input array is extended
when the filter overlaps a border. Default is ‘reflect’. Behavior
for each valid value is as follows:</p>
<dl class="last docutils">
<dt>‘reflect’ (<cite>d c b a | a b c d | d c b a</cite>)</dt>
<dd><p class="first last">The input is extended by reflecting about the edge of the last
pixel.</p>
</dd>
<dt>‘constant’ (<cite>k k k k | a b c d | k k k k</cite>)</dt>
<dd><p class="first last">The input is extended by filling all values beyond the edge with
the same constant value, defined by the <cite>cval</cite> parameter.</p>
</dd>
<dt>‘nearest’ (<cite>a a a a | a b c d | d d d d</cite>)</dt>
<dd><p class="first last">The input is extended by replicating the last pixel.</p>
</dd>
<dt>‘mirror’ (<cite>d c b | a b c d | c b a</cite>)</dt>
<dd><p class="first last">The input is extended by reflecting about the center of the last
pixel.</p>
</dd>
<dt>‘wrap’ (<cite>a b c d | a b c d | a b c d</cite>)</dt>
<dd><p class="first last">The input is extended by wrapping around to the opposite edge.</p>
</dd>
</dl>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first last">Value to fill past edges of input if <cite>mode</cite> is ‘constant’. Default
is 0.0.</p>
</dd>
<dt><strong>prefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Determines if the input array is prefiltered with <cite>spline_filter</cite>
before interpolation. The default is True, which will create a
temporary <cite>float64</cite> array of filtered values if <cite>order &gt; 1</cite>. If
setting this to False, the output will be slightly blurred if
<cite>order &gt; 1</cite>, unless the input is prefiltered, i.e. it is the result
of calling <cite>spline_filter</cite> on the original input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>map_coordinates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The result of transforming the input. The shape of the output is
derived from that of <cite>coordinates</cite> by dropping the first axis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spline_filter</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">geometric_transform</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.interpolate</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[  0.,   1.,   2.],</span>
<span class="go">       [  3.,   4.,   5.],</span>
<span class="go">       [  6.,   7.,   8.],</span>
<span class="go">       [  9.,  10.,  11.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 2.,  7.])</span>
</pre></div>
</div>
<p>Above, the interpolated value of a[0.5, 0.5] gives output[0], while
a[2, 1] is output[1].</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=-</span><span class="mf">33.3</span><span class="p">)</span>
<span class="go">array([  2. , -33.3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
<span class="go">array([ 2.,  8.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="go">array([ True, False], dtype=bool)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="optional-package">
<h3>optional_package<a class="headerlink" href="#optional-package" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.optional_package">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">optional_package</code><span class="sig-paren">(</span><em>name</em>, <em>trip_msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.optional_package" title="Permalink to this definition">¶</a></dt>
<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">package name</p>
</dd>
<dt><strong>trip_msg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or str</span></dt>
<dd><p class="first last">message to give when someone tries to use the return package, but we
could not import it, and have returned a TripWire object instead.
Default message if None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pkg_like</strong> <span class="classifier-delimiter">:</span> <span class="classifier">module or <code class="docutils literal notranslate"><span class="pre">TripWire</span></code> instance</span></dt>
<dd><p class="first last">If we can import the package, return it.  Otherwise return an object
raising an error when accessed</p>
</dd>
<dt><strong>have_pkg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if import for package was successful, false otherwise</p>
</dd>
<dt><strong>module_setup</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">callable usually set as <code class="docutils literal notranslate"><span class="pre">setup_module</span></code> in calling namespace, to allow
skipping tests.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="peak-values">
<h3>peak_values<a class="headerlink" href="#peak-values" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.peak_values">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">peak_values</code><span class="sig-paren">(</span><em>bundle</em>, <em>peaks</em>, <em>dt</em>, <em>pname</em>, <em>bname</em>, <em>subject</em>, <em>group</em>, <em>ind</em>, <em>dir</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.peak_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Peak_values function finds the peak direction and peak value of a point
on a streamline used while tracking (generating the tractogram) and
save it in hd5 file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bundle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Name of bundle being analyzed</p>
</dd>
<dt><strong>peaks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">peaks</span></dt>
<dd><p class="first last">contains peak directions and values</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">DataFrame to be populated</p>
</dd>
<dt><strong>pname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Name of the dti metric</p>
</dd>
<dt><strong>bname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Name of bundle being analyzed.</p>
</dd>
<dt><strong>subject</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">subject number as a string (e.g. 10001)</p>
</dd>
<dt><strong>group</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">which group subject belongs to (e.g. patient or control)</p>
</dd>
<dt><strong>ind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer list</span></dt>
<dd><p class="first last">ind tells which disk number a point belong.</p>
</dd>
<dt><strong>dir</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">path of output directory</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="set-number-of-points">
<h3>set_number_of_points<a class="headerlink" href="#set-number-of-points" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.set_number_of_points">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">set_number_of_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.set_number_of_points" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Change the number of points of streamlines</dt>
<dd>(either by downsampling or upsampling)</dd>
</dl>
<p>Change the number of points of streamlines in order to obtain
<cite>nb_points</cite>-1 segments of equal length. Points of streamlines will be
modified along the curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>streamlines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt>
<dd><p class="first last">If ndarray, must have shape (N,3) where N is the number of points
of the streamline.
If list, each item must be ndarray shape (Ni,3) where Ni is the number
of points of streamline i.
If <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a>, its <cite>common_shape</cite> must be 3.</p>
</dd>
<dt><strong>nb_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">integer representing number of points wanted along the curve.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_streamlines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt>
<dd><p class="first last">Results of the downsampling or upsampling process.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.tracking.streamline</span> <span class="k">import</span> <span class="n">set_number_of_points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>One streamline, a semi-circle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modified_streamline</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamline</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">modified_streamline</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Multiple streamlines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="p">[</span><span class="n">streamline</span><span class="p">,</span> <span class="n">streamline</span><span class="p">[::</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_streamlines</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamlines</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">streamlines</span><span class="p">]</span>
<span class="go">[100, 50]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_streamlines</span><span class="p">]</span>
<span class="go">[10, 10]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="transform-streamlines">
<h3>transform_streamlines<a class="headerlink" href="#transform-streamlines" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.stats.analysis.transform_streamlines">
<code class="descclassname">dipy.stats.analysis.</code><code class="descname">transform_streamlines</code><span class="sig-paren">(</span><em>streamlines</em>, <em>mat</em>, <em>in_place=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.stats.analysis.transform_streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply affine transformation to streamlines</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>streamlines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Streamlines</span></dt>
<dd><p class="first last">Streamlines object</p>
</dd>
<dt><strong>mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, (4, 4)</span></dt>
<dd><p class="first last">transformation matrix</p>
</dd>
<dt><strong>in_place</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True then change data in place.
Be careful changes input streamlines.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_streamlines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Streamlines</span></dt>
<dd><p class="first last">Sequence transformed 2D ndarrays of shape[-1]==3</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.sims.html" title="sims"
             >previous</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >API Reference</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2019, dipy developers &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
  </body>
</html>